## 2018 KAKAO BLIND RECRUITMENT[1차]

### 뉴스 클러스터링:newspaper:

유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 "자카드 유사도"라는 방법을 찾아냈다.

자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 `A`, `B` 사이의 자카드 유사도 `J(A, B)`는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.

예를 들어 집합 `A` = {1, 2, 3}, 집합 `B` = {2, 3, 4}라고 할 때, 교집합 `A ∩ B` = {2, 3}, 합집합 `A ∪ B` = {1, 2, 3, 4}이 되므로, 집합 `A`, `B` 사이의 자카드 유사도 `J(A, B)` = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 `J(A, B)` = 1로 정의한다.

자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 `A`는 원소 "1"을 3개 가지고 있고, 다중집합 `B`는 원소 "1"을 5개 가지고 있다고 하자. 이 다중집합의 교집합 `A ∩ B`는 원소 "1"을 min(3, 5)인 3개, 합집합 `A ∪ B`는 원소 "1"을 max(3, 5)인 5개 가지게 된다. 다중집합 `A` = {1, 1, 2, 2, 3}, 다중집합 `B` = {1, 2, 2, 4, 5}라고 하면, 교집합 `A ∩ B` = {1, 2, 2}, 합집합 `A ∪ B` = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 `J(A, B)` = 3/7, 약 0.42가 된다.

**입력 형식**

- 입력으로는 `str1`과 `str2`의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.
- 입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 "ab+"가 입력으로 들어오면, "ab"만 다중집합의 원소로 삼고, "b+"는 버린다.
- 다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. "AB"와 "Ab", "ab"는 같은 원소로 취급한다.

**출력 형식**

입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.

**예제 입출력**

| str1      | str2        | answer |
| --------- | ----------- | ------ |
| FRANCE    | french      | 16384  |
| handshake | shake hands | 65536  |
| aa1+aa2   | AAAA12      | 43690  |
| E=M*C^2   | e=m*c^2     | 65536  |

#### solution

- make_set 메서드를 이용하여 문자열 별로 집합을 만들어준다
  - 이 때, 자카드 유사도는 원소의 중복을 허용하고 있기 때문에 dictionary를 사용하여 counting을 한 후, 원소 뒤에 tagging을 해주는 방식으로 중복을 처리한다
- make_set의 결과물에 python set() 메서드인 intersect와 union을 활용하여 문제에서 요구하는 값을 리턴한다.

```python
def make_set(inp):
    out = {}
    _inp = inp.lower()
    for i in range(len(_inp)-1):
        s, s1 = _inp[i], _inp[i+1]
        # 알파벳 여부 확인
        if not s.isalpha():continue
        if not s1.isalpha():continue
        out[s+s1] = out.get(s+s1, 0)+1 # counter
    result = set()
    for s, cnt in out.items():
        # 원소별 count를 활용하여 tagging해준 후 result에 합해준다.
        # example ) out = {'aa':3} -> result = {'aa_0', 'aa_1', aa_2}
        result|=set([s+f'_{c}' for c in range(cnt)])
    return result

def solution(str1, str2):
    set1 = make_set(str1)
    set2 = make_set(str2)
    
    if not len(set1) and not len(set2):
        # 둘 다 공집합인 경우의 자카드 유사도는 1로 반환한다.
        return 65536
    # set()의 메서드들을 활용하여 문제의 답을 구한다.
    inter = set1.intersection(set2)
    union = set1.union(set2)
    return int(len(inter)/len(union)*65536)
```

### 셔틀버스:bus:

- 셔틀은 `09:00`부터 총 `n`회 `t`분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 `m`명의 승객이 탈 수 있다.
- 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 `09:00`에 도착한 셔틀은 자리가 있다면 `09:00`에 줄을 선 크루도 탈 수 있다.

일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.

단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 `23:59`에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.

**입력 형식**

셔틀 운행 횟수 `n`, 셔틀 운행 간격 `t`, 한 셔틀에 탈 수 있는 최대 크루 수 `m`, 크루가 대기열에 도착하는 시각을 모은 배열 `timetable`이 입력으로 주어진다.

- 0 ＜ `n` ≦ 10
- 0 ＜ `t` ≦ 60
- 0 ＜ `m` ≦ 45
- `timetable`은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 `HH:MM` 형식으로 이루어져 있다.
- 크루의 도착 시각 `HH:MM`은 `00:01`에서 `23:59` 사이이다.

**출력 형식**

콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 `HH:MM` 형식이며, `00:00`에서 `23:59` 사이의 값이 될 수 있다.

**입출력 예제**

| n    | t    | m    | timetable                                                    | answer  |
| ---- | ---- | ---- | ------------------------------------------------------------ | ------- |
| 1    | 1    | 5    | ["08:00", "08:01", "08:02", "08:03"]                         | "09:00" |
| 2    | 10   | 2    | ["09:10", "09:09", "08:00"]                                  | "09:09" |
| 2    | 1    | 2    | ["09:00", "09:00", "09:00", "09:00"]                         | "08:59" |
| 1    | 1    | 5    | ["00:01", "00:01", "00:01", "00:01", "00:01"]                | "00:00" |
| 1    | 1    | 1    | ["23:59"]                                                    | "09:00" |
| 10   | 60   | 45   | ["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"] | "18:00" |

#### solution

- 시간을 최소단위인 `분`단위로 변경해준다.
- 시작시간인 "09:00"(540)을 기준으로 운행시마다 t(분)를 더해준다.
- 버스 운행시각 전에 떠날 수 있는 크루들의 수를 센다(num_left)
  - n-i == 1일 때
    - num_left가 m보다 클 경우 answer는 운행시각과 남은 크루 중 m번째 크루의 도착시각 1분전 시각 중 작은 값이다.
    - 아니라면 answer는 운행시각이다
  - 아닌 경우
    - num_left가 m보다 클 경우 크루 테이블을 m명을 제외한 테이블로 갱신해준다.
    - 아니라면 크루 테이블을 num_left명을 제외한 테이블로 갱신해준다.

```python
def solution(n, t, m, timetable):
    times = [int(t.split(":")[0])*60+int(t.split(":")[1]) for t in timetable]
    times.sort() # 오름차순 정렬

    for i in range(n):
        time = 540 + i*t # 버스 도착 시간
        for num_left, left in enumerate(times):
            if left > time:
                break
        if n-i == 1: # last bus
            if num_left+1>=m:
                answer = min(time, times[m-1]-1)
            else:
                answer = time
            return "%.2d:%.2d"%(answer//60, answer%60) # format answer
        if j > m:
            times = times[m:]
        else:
            times = times[num_left:]
```

